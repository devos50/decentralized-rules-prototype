import numpy as np
from numpy import average
from sklearn.naive_bayes import GaussianNB


def compute_similarity_coefficient(user_votes, user_a: int, user_b: int) -> float:
    """
    Compute the similarity coefficient from the perspective of this user.

    This works as follows:
    We compare all votes of both A and B.
    Votes on tags generated by a rule are grouped together, and so are votes on the same tags.
    We then take the average of all absolute differences, and take the average of these differences.
    We then subtract this final value from 1, which gives a value in the interval [-1, 1].
    """
    votes_on_tags = {}

    for tag, vote in user_votes[user_a]:
        if tag not in votes_on_tags:
            votes_on_tags[tag] = ([], [])
        votes_on_tags[tag][0].append(1 if vote else -1)

    for tag, vote in user_votes[user_b]:
        if tag not in votes_on_tags:
            votes_on_tags[tag] = ([], [])
        votes_on_tags[tag][1].append(1 if vote else -1)

    diffs = []

    # For each tag, we compute the average rating by each user and compute the absolute difference.
    for tag_id, votes in votes_on_tags.items():
        votes_a, votes_b = votes
        if not votes_a or not votes_b:
            continue  # No overlap to work with

        diffs.append(abs(average(votes_a) - average(votes_b)))

    if not diffs:
        return 0

    return 1 - average(diffs)


def get_features_from_dataset(dataset, num_honest_users, num_spammers, as_user=0):
    # Read and prepare the data to train the classifier
    tags = set()
    user_votes = {}
    tag_creator = {}

    num_upvotes = 0
    num_downvotes = 0

    # Features
    user_reputation = {}
    subjective_user_reputation = {}
    similarities = {}

    with open(dataset) as scenario_file:
        for line in scenario_file:
            parts = line.strip().split(",")
            user_id = int(parts[1])
            vote = bool(int(parts[4]))
            tag = parts[2], parts[3]
            tags.add(tag)
            if tag not in tag_creator:
                tag_creator[tag] = user_id
            else:
                if user_id not in user_votes:
                    user_votes[user_id] = []
                user_votes[user_id].append((tag, vote))

            if vote:
                num_upvotes += 1
            else:
                num_downvotes += 1

    print("Upvotes: %d, downvotes: %d" % (num_upvotes, num_downvotes))

    # Determine the global reputation of each user (total upvotes / total votes)
    for user_votes_list in user_votes.values():
        for tag, is_upvote in user_votes_list:
            author = tag_creator[tag]
            if author not in user_reputation:
                user_reputation[author] = [0, 0]

            if is_upvote:
                user_reputation[author][0] += 1
            user_reputation[author][1] += 1

    #print(user_reputation)

    # Determine the subjective reputation of each user (total upvotes / total votes)
    for tag, is_upvote in user_votes[0]:
        author = tag_creator[tag]
        if author not in subjective_user_reputation:
            subjective_user_reputation[author] = [0, 0]

        if is_upvote:
            subjective_user_reputation[author][0] += 1
        subjective_user_reputation[author][1] += 1

    #print(subjective_user_reputation)

    # Determine similarities between voting histories
    for target_user in range(0, num_honest_users + num_spammers):
        similarity = compute_similarity_coefficient(user_votes, as_user, target_user)
        similarities[target_user] = similarity

    # Determine credibility
    for tag in tags:
        pass

    X = []
    for user in range(0, num_honest_users + num_spammers):
        if user == as_user:
            continue
        user_rep = (user_reputation[user][0] / user_reputation[user][1]) if user in user_reputation else 0
        subjective_user_rep = (subjective_user_reputation[user][0] / subjective_user_reputation[user][1]) if user in subjective_user_reputation else 0
        X.append([user_rep, subjective_user_rep, similarities[user]])
    X = np.array(X)
    y = [0] * (num_honest_users - 1) + [1] * num_spammers
    y = np.array(y)

    return X, y

# Training
X, y = get_features_from_dataset("scripts/create_movielens_experiment/data/scenarios/tag_experiment_100_training.scenario", 100, 100)
print(X)
print(y)
gnb = GaussianNB()
gnb.fit(X, y)

# Validation
print("Validating...")
X, y = get_features_from_dataset("scripts/create_movielens_experiment/data/scenarios/tag_experiment_100.scenario", 100, 100)
print(X)
print(y)

y_pred = gnb.predict(X)
for ind in range(len(y)):
    if y_pred[ind] != y[ind]:
        print("Predicted %d, actual: %d" % (y_pred[ind], y[ind]))
print("Number of mislabeled users out of a total %d user : %d" % (X.shape[0], (y != y_pred).sum()))
