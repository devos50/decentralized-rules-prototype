import random
from typing import Set

import networkx as nx
import numpy as np
from numpy import average

from core import GENESIS_HASH


class TrustDatabase:

    def __init__(self, my_id, votes_db, tags_db):
        self.my_id = my_id
        self.similarity_scores = {}
        self.max_flows = {}
        self.user_reputations = {}
        self.votes_db = votes_db
        self.tags_db = tags_db

        self.pagerank_scores = {}

    def select_vote_dag_tips(self) -> Set[int]:
        """
        Determine the tips on which we build our next vote.
        """
        # Copy the DAG and reverse the edges
        walk_dag = nx.DiGraph()
        walk_dag.add_node(GENESIS_HASH)
        for from_edge, to_edge in self.votes_db.vote_dag.edges():
            from_vote = self.votes_db.votes[from_edge]
            user_rep = self.user_reputations[from_vote.user_id] if from_vote.user_id in self.user_reputations else 0
            if user_rep > 0:
                walk_dag.add_edge(to_edge, from_edge, weight=user_rep)

        self.pagerank_scores = nx.pagerank_numpy(walk_dag, personalization={GENESIS_HASH: 1}, alpha=1)

        ssum = 0
        node_ids = []
        exit_probs = []
        tips = [node for node, out_degree in walk_dag.out_degree if out_degree == 0]
        for tip in tips:
            if self.pagerank_scores[tip] <= 0:
                continue
            ssum += self.pagerank_scores[tip]
            node_ids.append(tip)
            exit_probs.append(self.pagerank_scores[tip])

        # Normalize the exit probabilities in the tips
        for ind in range(len(exit_probs)):
            exit_probs[ind] /= ssum

        return np.random.choice(node_ids, min(len(exit_probs), 2), p=exit_probs)

    def compute_similarities(self):
        """
        Compute the similarity scores to all neighbours, based on the acquired local knowledge.
        """
        self.similarity_scores = {}
        for uid1 in self.votes_db.votes_per_user.keys():
            for uid2 in self.votes_db.votes_per_user.keys():
                if uid1 == uid2 and uid1 != self.my_id:
                    continue
                similarity = self.compute_similarity_coefficient(uid1, uid2)

                if uid1 not in self.similarity_scores:
                    self.similarity_scores[uid1] = {}
                if uid2 not in self.similarity_scores:
                    self.similarity_scores[uid1][uid2] = []

                self.similarity_scores[uid1][uid2] = similarity

    def get_similarity_coefficient(self, uid1, uid2):
        return self.similarity_scores[uid1][uid2] if uid1 in self.similarity_scores and uid2 in self.similarity_scores[uid1] else 0

    def compute_similarity_coefficient(self, user_a: int, user_b: int) -> float:
        """
        Compute the similarity coefficient from the perspective of this user.

        This works as follows:
        We compare all votes of both A and B.
        Votes on tags generated by a rule are grouped together, and so are votes on the same tags.
        We then take the average of all absolute differences, and take the average of these differences.
        We then subtract this final value from 1, which gives a value in the interval [-1, 1].
        """
        votes_on_rules = {}  # Rule => ([...], [...])
        votes_on_tags = {}

        for vote in self.votes_db.get_votes_for_user(user_a):
            for rule_id in vote.rules_ids:
                if rule_id not in votes_on_rules:
                    votes_on_rules[rule_id] = ([], [])
                votes_on_rules[rule_id][0].append(1 if vote.is_accurate else -1)

            if (vote.cid, vote.tag) not in votes_on_tags:
                votes_on_tags[(vote.cid, vote.tag)] = ([], [])
            votes_on_tags[(vote.cid, vote.tag)][0].append(1 if vote.is_accurate else -1)

        for vote in self.votes_db.get_votes_for_user(user_b):
            for rule_id in vote.rules_ids:
                if rule_id not in votes_on_rules:
                    votes_on_rules[rule_id] = ([], [])
                votes_on_rules[rule_id][1].append(1 if vote.is_accurate else -1)

            if (vote.cid, vote.tag) not in votes_on_tags:
                votes_on_tags[(vote.cid, vote.tag)] = ([], [])
            votes_on_tags[(vote.cid, vote.tag)][1].append(1 if vote.is_accurate else -1)

        #print("Votes between %s and %s: %s (rules) %s (tags)" % (user_a, user_b, votes_on_rules, votes_on_tags))

        diffs = []

        # For each rule, we compute the average rating by each user and compute the absolute difference.
        for rule_id, votes in votes_on_rules.items():
            votes_a, votes_b = votes
            if not votes_a or not votes_b:
                continue  # No overlap to work with

            diffs.append(abs(average(votes_a) - average(votes_b)))

        # For each tag, we compute the average rating by each user and compute the absolute difference.
        for tag_id, votes in votes_on_tags.items():
            votes_a, votes_b = votes
            if not votes_a or not votes_b:
                continue  # No overlap to work with

            diffs.append(abs(average(votes_a) - average(votes_b)))

        if not diffs:
            return 0

        return 1 - average(diffs)

    def compute_flows(self):
        self.max_flows = {}

        # Construct the flow graph
        other_user_ids = set()
        flow_graph = nx.Graph()
        flow_graph.add_node(self.my_id)
        for from_user_id in self.similarity_scores.keys():
            for to_user_id, score in self.similarity_scores[from_user_id].items():
                if from_user_id == self.my_id and to_user_id == self.my_id:
                    continue

                if from_user_id == self.my_id and to_user_id != self.my_id:
                    other_user_ids.add(to_user_id)
                if score != 0:
                    flow_graph.add_edge(from_user_id, to_user_id, capacity=score)

        for other_user_id in other_user_ids:
            flow_value = self.compute_sign_aware_flow(flow_graph, self.my_id, other_user_id)
            #flow_value, _ = nx.maximum_flow(flow_graph, self.my_id, other_user_id)
            self.max_flows[other_user_id] = flow_value

        # Your own flow is the maximum of flows to the other nodes.
        # This ensures that your opinion is weighted in as equal as the peer you trust most.
        self.max_flows[self.my_id] = max(self.max_flows.values()) if self.max_flows else 1

        # Scale the values to the interval [-1, 1]
        min_flow = min(self.max_flows.values())
        max_flow = max(self.max_flows.values())
        for user_id in self.max_flows:
            f = self.max_flows[user_id]
            if max_flow == min_flow:
                self.max_flows[user_id] = 0
            else:
                self.max_flows[user_id] = 2 * ((f - min_flow) / (max_flow - min_flow)) - 1

        #print(self.similarity_scores[self.my_id])
        #print(self.max_flows)

    def compute_sign_aware_flow(self, orig_graph, s, t):
        flow = 0
        #print("S: %d, t: %d" % (s, t))
        flow_graph = orig_graph.copy()
        for edge in flow_graph.edges():
            flow_graph[edge[0]][edge[1]]["flow"] = 0

        while True:
            queue = [s]
            pred = {}
            while queue:
                cur_node = queue.pop(0)
                for edge in flow_graph.edges(cur_node, data=True):
                    cap = edge[2]["capacity"]
                    if edge[1] not in pred and edge[1] != s and (cap >= 0 or (edge[1] == t)) and abs(cap) > edge[2]["flow"]:
                        pred[edge[1]] = edge
                        queue.append(edge[1])

            if t not in pred:
                break
            else:
                df = 100000000
                e = pred[t]
                while True:  # Determine the flow
                    df = min(df, abs(e[2]["capacity"]) - e[2]["flow"])
                    if e[0] not in pred:
                        # We are done with this path - if the last edge of the path was negative, flip the sign
                        if pred[t][2]["capacity"] < 0:
                            df *= -1
                        break
                    e = pred[e[0]]

                e = pred[t]
                while True:  # Update edges
                    e[2]["flow"] += abs(df)
                    if e[0] not in pred:
                        break
                    e = pred[e[0]]
                flow += df

        return flow

    def compute_graph_influences(self):
        sums_per_user = {}
        for vote_id in self.pagerank_scores.keys():
            if vote_id == GENESIS_HASH:
                continue
            vote = self.votes_db.votes[vote_id]
            if vote.user_id not in sums_per_user:
                sums_per_user[vote.user_id] = 0
            sums_per_user[vote.user_id] += self.pagerank_scores[vote_id]

        # Normalize scores
        ssum = sum(sums_per_user.values())
        for user_id in sums_per_user.keys():
            sums_per_user[user_id] /= ssum

        print(sums_per_user)
